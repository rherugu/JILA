"use strict";
/**
 * This module provides a HttpClient that can be plugged into stripe-node
 * that will allow the user to use stripe-node in extensions if the Dashboard
 * provides a `stripeApiFetch` function that will relay API calls through the
 * Dashboard and piggy back on the user's Dashboard session.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AUTHORIZATION_VALUE = exports.AUTHORIZATION_HEADER = exports.createHttpClient = exports.STRIPE_API_KEY = exports.StripeAppsHttpClient = void 0;
const invariant_1 = __importDefault(require("invariant"));
const apiFetch_1 = require("./apiFetch");
const matchesStripeKey = /[ps]k_(test|live)_[A-Za-z0-9]+/;
class StripeAppsHttpResponse {
    constructor(resp) {
        this._resp = resp;
    }
    getHeaders() {
        return this._resp.headers;
    }
    getStatusCode() {
        return this._resp.status;
    }
    getRawResponse() {
        return this._resp;
    }
    // eslint-disable-next-line class-methods-use-this
    toStream() {
        throw new Error('Streams have not been implemented in the Stripe HTTP client');
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    toJSON() {
        const { json } = this._resp;
        if (json === undefined) {
            return Promise.reject(new Error('Response body undefined'));
        }
        else {
            return Promise.resolve(json);
        }
    }
}
class StripeAppsHttpClient {
    constructor(fetch) {
        this._fetch = fetch;
    }
    // eslint-disable-next-line class-methods-use-this
    getClientName() {
        return 'stripe-ui-extension';
    }
    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, invariant_1.default)(protocol === 'https', 'Must use https connections in UI extensions');
            const fetchOptions = {
                method,
                headers,
            };
            if (requestData) {
                fetchOptions.body = requestData;
            }
            const authHeader = headers.Authorization;
            if (authHeader && matchesStripeKey.test(authHeader)) {
                throw new Error('Do not use actual stripe keys when using the Stripe JS API client with UI extesions.\n\n Instead, use `STRIPE_API_KEY` from `@stripe/ui-extension-sdk/http_client` as a placeholder.');
            }
            const resp = yield this._fetch(path, fetchOptions);
            // TODO: Add support for timeouts.
            return new StripeAppsHttpResponse(resp);
        });
    }
}
exports.StripeAppsHttpClient = StripeAppsHttpClient;
// DO NOT change this string without a deprecation plan. The runtime checks to make sure that this
// exact string is passed, otherwise it will throw an error.
// See: manage/frontend/src/tailor/extensions/host/api_fetch.js
exports.STRIPE_API_KEY = 'DO_NOT_PASS_A_REAL_API_KEY';
const createHttpClient = () => new StripeAppsHttpClient(apiFetch_1.stripeApiFetch);
exports.createHttpClient = createHttpClient;
exports.AUTHORIZATION_HEADER = 'Authorization';
exports.AUTHORIZATION_VALUE = `Bearer ${exports.STRIPE_API_KEY}`;
//# sourceMappingURL=httpClient.js.map