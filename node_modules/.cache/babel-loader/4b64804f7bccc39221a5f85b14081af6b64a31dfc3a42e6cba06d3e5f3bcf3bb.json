{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar memory = require('./memory.js');\nvar basic = require('./encoding/basic.js');\nconst CALL = 0;\nconst RESULT = 1;\nconst TERMINATE = 2;\nconst RELEASE = 3;\nconst FUNCTION_APPLY = 5;\nconst FUNCTION_RESULT = 6;\n\n/**\n * An endpoint wraps around a messenger, acting as the intermediary for all\n * messages both send from, and received by, that messenger. The endpoint sends\n * all messages as arrays, where the first element is the message type, and the\n * second is the arguments for that message (as an array). For messages that send\n * meaningful content across the wire (e.g., arguments to function calls, return\n * results), the endpoint first encodes these values.\n *\n * Encoding is done using a CBOR-like encoding scheme. The value is encoded into\n * an array buffer, and is paired with an additional array buffer that contains all\n * the strings used in that message (in the encoded value, strings are encoded as\n * their index in the \"strings\" encoding to reduce the cost of heavily-duplicated\n * strings, which is more likely in payloads containing UI). This encoding also takes\n * care of encoding functions: it uses a \"tagged\" item in CBOR to represent a\n * function as a string ID, which the opposite endpoint will be capable of turning\n * into a consistent, memory-manageable function proxy.\n *\n * The main CBOR encoding is entirely take from the [cbor.js package](https://github.com/paroga/cbor-js).\n * The special behavior for encoding strings and functions was then added in to the\n * encoder and decoder. For additional details on CBOR:\n *\n * @see https://tools.ietf.org/html/rfc7049\n */\nfunction createEndpoint(initialMessenger, {\n  uuid = defaultUuid,\n  createEncoder = basic.createBasicEncoder,\n  callable\n} = {}) {\n  let terminated = false;\n  let messenger = initialMessenger;\n  const activeApi = new Map();\n  const callIdsToResolver = new Map();\n  const call = createCallable(handlerForCall, callable);\n  const encoder = createEncoder({\n    uuid,\n    release(id) {\n      send(RELEASE, [id]);\n    },\n    call(id, args, retainedBy) {\n      const callId = uuid();\n      const done = waitForResult(callId, retainedBy);\n      const [encoded, transferables] = encoder.encode(args);\n      send(FUNCTION_APPLY, [callId, id, encoded], transferables);\n      return done;\n    }\n  });\n  messenger.addEventListener('message', listener);\n  return {\n    call,\n    replace(newMessenger) {\n      const oldMessenger = messenger;\n      messenger = newMessenger;\n      oldMessenger.removeEventListener('message', listener);\n      newMessenger.addEventListener('message', listener);\n    },\n    expose(api) {\n      for (const key of Object.keys(api)) {\n        const value = api[key];\n        if (typeof value === 'function') {\n          activeApi.set(key, value);\n        } else {\n          activeApi.delete(key);\n        }\n      }\n    },\n    callable(...newCallable) {\n      // If no callable methods are supplied initially, we use a Proxy instead,\n      // so all methods end up being treated as callable by default.\n      if (callable == null) return;\n      for (const method of newCallable) {\n        Object.defineProperty(call, method, {\n          value: handlerForCall(method),\n          writable: false,\n          configurable: true,\n          enumerable: true\n        });\n      }\n    },\n    terminate() {\n      send(TERMINATE, undefined);\n      terminate();\n      if (messenger.terminate) {\n        messenger.terminate();\n      }\n    }\n  };\n  function send(type, args, transferables) {\n    if (terminated) {\n      return;\n    }\n    messenger.postMessage(args ? [type, args] : [type], transferables);\n  }\n  async function listener(event) {\n    const {\n      data\n    } = event;\n    if (data == null || !Array.isArray(data)) {\n      return;\n    }\n    switch (data[0]) {\n      case TERMINATE:\n        {\n          terminate();\n          break;\n        }\n      case CALL:\n        {\n          const stackFrame = new memory.StackFrame();\n          const [id, property, args] = data[1];\n          const func = activeApi.get(property);\n          try {\n            if (func == null) {\n              throw new Error(`No '${property}' method is exposed on this endpoint`);\n            }\n            const [encoded, transferables] = encoder.encode(await func(...encoder.decode(args, [stackFrame])));\n            send(RESULT, [id, undefined, encoded], transferables);\n          } catch (error) {\n            const {\n              name,\n              message,\n              stack\n            } = error;\n            send(RESULT, [id, {\n              name,\n              message,\n              stack\n            }]);\n            throw error;\n          } finally {\n            stackFrame.release();\n          }\n          break;\n        }\n      case RESULT:\n        {\n          const [callId] = data[1];\n          callIdsToResolver.get(callId)(...data[1]);\n          callIdsToResolver.delete(callId);\n          break;\n        }\n      case RELEASE:\n        {\n          const [id] = data[1];\n          encoder.release(id);\n          break;\n        }\n      case FUNCTION_RESULT:\n        {\n          const [callId] = data[1];\n          callIdsToResolver.get(callId)(...data[1]);\n          callIdsToResolver.delete(callId);\n          break;\n        }\n      case FUNCTION_APPLY:\n        {\n          const [callId, funcId, args] = data[1];\n          try {\n            const result = await encoder.call(funcId, args);\n            const [encoded, transferables] = encoder.encode(result);\n            send(FUNCTION_RESULT, [callId, undefined, encoded], transferables);\n          } catch (error) {\n            const {\n              name,\n              message,\n              stack\n            } = error;\n            send(FUNCTION_RESULT, [callId, {\n              name,\n              message,\n              stack\n            }]);\n            throw error;\n          }\n          break;\n        }\n    }\n  }\n  function handlerForCall(property) {\n    return (...args) => {\n      if (terminated) {\n        return Promise.reject(new Error('You attempted to call a function on a terminated web worker.'));\n      }\n      if (typeof property !== 'string' && typeof property !== 'number') {\n        return Promise.reject(new Error(`Canâ€™t call a symbol method on a remote endpoint: ${property.toString()}`));\n      }\n      const id = uuid();\n      const done = waitForResult(id);\n      const [encoded, transferables] = encoder.encode(args);\n      send(CALL, [id, property, encoded], transferables);\n      return done;\n    };\n  }\n  function waitForResult(id, retainedBy) {\n    return new Promise((resolve, reject) => {\n      callIdsToResolver.set(id, (_, errorResult, value) => {\n        if (errorResult == null) {\n          resolve(value && encoder.decode(value, retainedBy));\n        } else {\n          const error = new Error();\n          Object.assign(error, errorResult);\n          reject(error);\n        }\n      });\n    });\n  }\n  function terminate() {\n    var _encoder$terminate;\n    terminated = true;\n    activeApi.clear();\n    callIdsToResolver.clear();\n    (_encoder$terminate = encoder.terminate) === null || _encoder$terminate === void 0 ? void 0 : _encoder$terminate.call(encoder);\n    messenger.removeEventListener('message', listener);\n  }\n}\nfunction defaultUuid() {\n  return `${uuidSegment()}-${uuidSegment()}-${uuidSegment()}-${uuidSegment()}`;\n}\nfunction uuidSegment() {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n}\nfunction createCallable(handlerForCall, callable) {\n  let call;\n  if (callable == null) {\n    if (typeof Proxy !== 'function') {\n      throw new Error(`You must pass an array of callable methods in environments without Proxies.`);\n    }\n    const cache = new Map();\n    call = new Proxy({}, {\n      get(_target, property) {\n        if (cache.has(property)) {\n          return cache.get(property);\n        }\n        const handler = handlerForCall(property);\n        cache.set(property, handler);\n        return handler;\n      }\n    });\n  } else {\n    call = {};\n    for (const method of callable) {\n      Object.defineProperty(call, method, {\n        value: handlerForCall(method),\n        writable: false,\n        configurable: true,\n        enumerable: true\n      });\n    }\n  }\n  return call;\n}\nexports.CALL = CALL;\nexports.FUNCTION_APPLY = FUNCTION_APPLY;\nexports.FUNCTION_RESULT = FUNCTION_RESULT;\nexports.RELEASE = RELEASE;\nexports.RESULT = RESULT;\nexports.TERMINATE = TERMINATE;\nexports.createEndpoint = createEndpoint;","map":{"version":3,"names":["Object","defineProperty","exports","value","memory","require","basic","CALL","RESULT","TERMINATE","RELEASE","FUNCTION_APPLY","FUNCTION_RESULT","createEndpoint","initialMessenger","uuid","defaultUuid","createEncoder","createBasicEncoder","callable","terminated","messenger","activeApi","Map","callIdsToResolver","call","createCallable","handlerForCall","encoder","release","id","send","args","retainedBy","callId","done","waitForResult","encoded","transferables","encode","addEventListener","listener","replace","newMessenger","oldMessenger","removeEventListener","expose","api","key","keys","set","delete","newCallable","method","writable","configurable","enumerable","terminate","undefined","type","postMessage","event","data","Array","isArray","stackFrame","StackFrame","property","func","get","Error","decode","error","name","message","stack","funcId","result","Promise","reject","toString","resolve","_","errorResult","assign","_encoder$terminate","clear","uuidSegment","Math","floor","random","Number","MAX_SAFE_INTEGER","Proxy","cache","_target","has","handler"],"sources":["/Users/raghavvherugu/Desktop/Projects/name/Jila/node_modules/@remote-ui/rpc/build/cjs/endpoint.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar memory = require('./memory.js');\nvar basic = require('./encoding/basic.js');\n\nconst CALL = 0;\nconst RESULT = 1;\nconst TERMINATE = 2;\nconst RELEASE = 3;\nconst FUNCTION_APPLY = 5;\nconst FUNCTION_RESULT = 6;\n\n/**\n * An endpoint wraps around a messenger, acting as the intermediary for all\n * messages both send from, and received by, that messenger. The endpoint sends\n * all messages as arrays, where the first element is the message type, and the\n * second is the arguments for that message (as an array). For messages that send\n * meaningful content across the wire (e.g., arguments to function calls, return\n * results), the endpoint first encodes these values.\n *\n * Encoding is done using a CBOR-like encoding scheme. The value is encoded into\n * an array buffer, and is paired with an additional array buffer that contains all\n * the strings used in that message (in the encoded value, strings are encoded as\n * their index in the \"strings\" encoding to reduce the cost of heavily-duplicated\n * strings, which is more likely in payloads containing UI). This encoding also takes\n * care of encoding functions: it uses a \"tagged\" item in CBOR to represent a\n * function as a string ID, which the opposite endpoint will be capable of turning\n * into a consistent, memory-manageable function proxy.\n *\n * The main CBOR encoding is entirely take from the [cbor.js package](https://github.com/paroga/cbor-js).\n * The special behavior for encoding strings and functions was then added in to the\n * encoder and decoder. For additional details on CBOR:\n *\n * @see https://tools.ietf.org/html/rfc7049\n */\nfunction createEndpoint(initialMessenger, {\n  uuid = defaultUuid,\n  createEncoder = basic.createBasicEncoder,\n  callable\n} = {}) {\n  let terminated = false;\n  let messenger = initialMessenger;\n  const activeApi = new Map();\n  const callIdsToResolver = new Map();\n  const call = createCallable(handlerForCall, callable);\n  const encoder = createEncoder({\n    uuid,\n\n    release(id) {\n      send(RELEASE, [id]);\n    },\n\n    call(id, args, retainedBy) {\n      const callId = uuid();\n      const done = waitForResult(callId, retainedBy);\n      const [encoded, transferables] = encoder.encode(args);\n      send(FUNCTION_APPLY, [callId, id, encoded], transferables);\n      return done;\n    }\n\n  });\n  messenger.addEventListener('message', listener);\n  return {\n    call,\n\n    replace(newMessenger) {\n      const oldMessenger = messenger;\n      messenger = newMessenger;\n      oldMessenger.removeEventListener('message', listener);\n      newMessenger.addEventListener('message', listener);\n    },\n\n    expose(api) {\n      for (const key of Object.keys(api)) {\n        const value = api[key];\n\n        if (typeof value === 'function') {\n          activeApi.set(key, value);\n        } else {\n          activeApi.delete(key);\n        }\n      }\n    },\n\n    callable(...newCallable) {\n      // If no callable methods are supplied initially, we use a Proxy instead,\n      // so all methods end up being treated as callable by default.\n      if (callable == null) return;\n\n      for (const method of newCallable) {\n        Object.defineProperty(call, method, {\n          value: handlerForCall(method),\n          writable: false,\n          configurable: true,\n          enumerable: true\n        });\n      }\n    },\n\n    terminate() {\n      send(TERMINATE, undefined);\n      terminate();\n\n      if (messenger.terminate) {\n        messenger.terminate();\n      }\n    }\n\n  };\n\n  function send(type, args, transferables) {\n    if (terminated) {\n      return;\n    }\n\n    messenger.postMessage(args ? [type, args] : [type], transferables);\n  }\n\n  async function listener(event) {\n    const {\n      data\n    } = event;\n\n    if (data == null || !Array.isArray(data)) {\n      return;\n    }\n\n    switch (data[0]) {\n      case TERMINATE:\n        {\n          terminate();\n          break;\n        }\n\n      case CALL:\n        {\n          const stackFrame = new memory.StackFrame();\n          const [id, property, args] = data[1];\n          const func = activeApi.get(property);\n\n          try {\n            if (func == null) {\n              throw new Error(`No '${property}' method is exposed on this endpoint`);\n            }\n\n            const [encoded, transferables] = encoder.encode(await func(...encoder.decode(args, [stackFrame])));\n            send(RESULT, [id, undefined, encoded], transferables);\n          } catch (error) {\n            const {\n              name,\n              message,\n              stack\n            } = error;\n            send(RESULT, [id, {\n              name,\n              message,\n              stack\n            }]);\n            throw error;\n          } finally {\n            stackFrame.release();\n          }\n\n          break;\n        }\n\n      case RESULT:\n        {\n          const [callId] = data[1];\n          callIdsToResolver.get(callId)(...data[1]);\n          callIdsToResolver.delete(callId);\n          break;\n        }\n\n      case RELEASE:\n        {\n          const [id] = data[1];\n          encoder.release(id);\n          break;\n        }\n\n      case FUNCTION_RESULT:\n        {\n          const [callId] = data[1];\n          callIdsToResolver.get(callId)(...data[1]);\n          callIdsToResolver.delete(callId);\n          break;\n        }\n\n      case FUNCTION_APPLY:\n        {\n          const [callId, funcId, args] = data[1];\n\n          try {\n            const result = await encoder.call(funcId, args);\n            const [encoded, transferables] = encoder.encode(result);\n            send(FUNCTION_RESULT, [callId, undefined, encoded], transferables);\n          } catch (error) {\n            const {\n              name,\n              message,\n              stack\n            } = error;\n            send(FUNCTION_RESULT, [callId, {\n              name,\n              message,\n              stack\n            }]);\n            throw error;\n          }\n\n          break;\n        }\n    }\n  }\n\n  function handlerForCall(property) {\n    return (...args) => {\n      if (terminated) {\n        return Promise.reject(new Error('You attempted to call a function on a terminated web worker.'));\n      }\n\n      if (typeof property !== 'string' && typeof property !== 'number') {\n        return Promise.reject(new Error(`Canâ€™t call a symbol method on a remote endpoint: ${property.toString()}`));\n      }\n\n      const id = uuid();\n      const done = waitForResult(id);\n      const [encoded, transferables] = encoder.encode(args);\n      send(CALL, [id, property, encoded], transferables);\n      return done;\n    };\n  }\n\n  function waitForResult(id, retainedBy) {\n    return new Promise((resolve, reject) => {\n      callIdsToResolver.set(id, (_, errorResult, value) => {\n        if (errorResult == null) {\n          resolve(value && encoder.decode(value, retainedBy));\n        } else {\n          const error = new Error();\n          Object.assign(error, errorResult);\n          reject(error);\n        }\n      });\n    });\n  }\n\n  function terminate() {\n    var _encoder$terminate;\n\n    terminated = true;\n    activeApi.clear();\n    callIdsToResolver.clear();\n    (_encoder$terminate = encoder.terminate) === null || _encoder$terminate === void 0 ? void 0 : _encoder$terminate.call(encoder);\n    messenger.removeEventListener('message', listener);\n  }\n}\n\nfunction defaultUuid() {\n  return `${uuidSegment()}-${uuidSegment()}-${uuidSegment()}-${uuidSegment()}`;\n}\n\nfunction uuidSegment() {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n}\n\nfunction createCallable(handlerForCall, callable) {\n  let call;\n\n  if (callable == null) {\n    if (typeof Proxy !== 'function') {\n      throw new Error(`You must pass an array of callable methods in environments without Proxies.`);\n    }\n\n    const cache = new Map();\n    call = new Proxy({}, {\n      get(_target, property) {\n        if (cache.has(property)) {\n          return cache.get(property);\n        }\n\n        const handler = handlerForCall(property);\n        cache.set(property, handler);\n        return handler;\n      }\n\n    });\n  } else {\n    call = {};\n\n    for (const method of callable) {\n      Object.defineProperty(call, method, {\n        value: handlerForCall(method),\n        writable: false,\n        configurable: true,\n        enumerable: true\n      });\n    }\n  }\n\n  return call;\n}\n\nexports.CALL = CALL;\nexports.FUNCTION_APPLY = FUNCTION_APPLY;\nexports.FUNCTION_RESULT = FUNCTION_RESULT;\nexports.RELEASE = RELEASE;\nexports.RESULT = RESULT;\nexports.TERMINATE = TERMINATE;\nexports.createEndpoint = createEndpoint;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}