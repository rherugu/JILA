{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar rpc = require('@remote-ui/rpc');\nvar types = require('./types.js');\nvar utilities = require('./utilities.js');\nconst FUNCTION_CURRENT_IMPLEMENTATION_KEY = '__current';\nconst EMPTY_OBJECT = {};\nconst EMPTY_ARRAY = [];\nfunction createRemoteRoot(channel, {\n  strict = true,\n  components\n} = {}) {\n  let currentId = 0;\n  const rootInternals = {\n    strict,\n    mounted: false,\n    channel,\n    children: EMPTY_ARRAY,\n    nodes: new WeakSet(),\n    parents: new WeakMap(),\n    tops: new WeakMap(),\n    components: new WeakMap(),\n    fragments: new WeakMap()\n  };\n  if (strict) Object.freeze(components);\n  const remoteRoot = {\n    kind: types.KIND_ROOT,\n    options: strict ? Object.freeze({\n      strict,\n      components\n    }) : {\n      strict,\n      components\n    },\n    get children() {\n      return rootInternals.children;\n    },\n    createComponent(type, ...rest) {\n      if (components && components.indexOf(type) < 0) {\n        throw new Error(`Unsupported component: ${type}`);\n      }\n      const [initialProps, initialChildren, ...moreChildren] = rest;\n      const normalizedInitialProps = initialProps !== null && initialProps !== void 0 ? initialProps : {};\n      const normalizedInitialChildren = [];\n      const normalizedInternalProps = {};\n      if (initialProps) {\n        for (const key of Object.keys(initialProps)) {\n          // \"children\" as a prop can be extremely confusing with the \"children\" of\n          // a component. In React, a \"child\" can be anything, but once it reaches\n          // a host environment (like this remote `Root`), we want \"children\" to have\n          // only one meaning: the actual, resolved children components and text.\n          //\n          // To enforce this, we delete any prop named \"children\". We don’t take a copy\n          // of the props for performance, so a user calling this function must do so\n          // with an object that can handle being mutated.\n          if (key === 'children') continue;\n          normalizedInternalProps[key] = makeValueHotSwappable(serializeProp(initialProps[key]));\n        }\n      }\n      if (initialChildren) {\n        if (Array.isArray(initialChildren)) {\n          for (const child of initialChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        } else {\n          normalizedInitialChildren.push(normalizeChild(initialChildren, remoteRoot)); // The complex tuple type of `rest` makes it so `moreChildren` is\n          // incorrectly inferred as potentially being the props of the component,\n          // lazy casting since we know it will be an array of child elements\n          // (or empty).\n\n          for (const child of moreChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        }\n      }\n      const id = `${currentId++}`;\n      const internals = {\n        externalProps: strict ? Object.freeze(normalizedInitialProps) : normalizedInitialProps,\n        internalProps: normalizedInternalProps,\n        children: strict ? Object.freeze(normalizedInitialChildren) : normalizedInitialChildren\n      };\n      const component = {\n        kind: types.KIND_COMPONENT,\n        get children() {\n          return internals.children;\n        },\n        get props() {\n          return internals.externalProps;\n        },\n        get remoteProps() {\n          return internals.internalProps;\n        },\n        remove: () => remove(component),\n        updateProps: newProps => updateProps(component, newProps, internals, rootInternals),\n        append: (...children) => append(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(component, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(component, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually, which we do below. If we just `as any`\n        // the whole object, we lose the implicit argument types for the\n        // methods above.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.components.set(component, internals);\n      Object.defineProperty(component, 'type', {\n        value: type,\n        configurable: false,\n        writable: false,\n        enumerable: true\n      });\n      makePartOfTree(component, rootInternals);\n      makeRemote(component, id, remoteRoot);\n      for (const child of internals.children) {\n        moveNodeToContainer(component, child, rootInternals);\n      }\n      return component;\n    },\n    createText(content = '') {\n      const id = `${currentId++}`;\n      const internals = {\n        text: content\n      };\n      const update = newText => updateText(text, newText, internals, rootInternals);\n      const text = {\n        kind: types.KIND_TEXT,\n        get text() {\n          return internals.text;\n        },\n        update,\n        updateText: update,\n        remove: () => remove(text),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      makePartOfTree(text, rootInternals);\n      makeRemote(text, id, remoteRoot);\n      return text;\n    },\n    createFragment() {\n      const id = `${currentId++}`;\n      const internals = {\n        children: strict ? Object.freeze([]) : []\n      };\n      const fragment = {\n        kind: types.KIND_FRAGMENT,\n        get children() {\n          return internals.children;\n        },\n        append: (...children) => append(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(fragment, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(fragment, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.fragments.set(fragment, internals);\n      makePartOfTree(fragment, rootInternals);\n      makeRemote(fragment, id, remoteRoot);\n      return fragment;\n    },\n    append: (...children) => append(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    appendChild: child => appendChild(remoteRoot, normalizeChild(child, remoteRoot), rootInternals, rootInternals),\n    replaceChildren: (...children) => replaceChildren(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    removeChild: child => removeChild(remoteRoot, child, rootInternals, rootInternals),\n    insertBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n    insertChildBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n    mount() {\n      if (rootInternals.mounted) return Promise.resolve();\n      rootInternals.mounted = true;\n      return Promise.resolve(channel(types.ACTION_MOUNT, rootInternals.children.map(serializeChild)));\n    }\n  };\n  return remoteRoot;\n}\nfunction connected(element, {\n  tops\n}) {\n  var _tops$get;\n  return ((_tops$get = tops.get(element)) === null || _tops$get === void 0 ? void 0 : _tops$get.kind) === types.KIND_ROOT;\n}\nfunction allDescendants(element, withEach) {\n  const recurse = element => {\n    if ('children' in element) {\n      for (const child of element.children) {\n        withEach(child);\n        recurse(child);\n      }\n    }\n  };\n  recurse(element);\n}\nfunction perform(element, rootInternals, {\n  remote,\n  local\n}) {\n  const {\n    mounted,\n    channel\n  } = rootInternals;\n  if (mounted && (element.kind === types.KIND_ROOT || connected(element, rootInternals))) {\n    // should only create context once async queue is cleared\n    remote(channel); // technically, we should be waiting for the remote update to apply,\n    // then apply it locally. The implementation below is too naive because\n    // it allows local updates to get out of sync with remote ones.\n    // if (remoteResult == null || !('then' in remoteResult)) {\n    //   local();\n    //   return;\n    // } else {\n    //   return remoteResult.then(() => {\n    //     local();\n    //   });\n    // }\n  }\n\n  local();\n}\nfunction updateText(text, newText, internals, rootInternals) {\n  return perform(text, rootInternals, {\n    remote: channel => channel(types.ACTION_UPDATE_TEXT, text.id, newText),\n    local: () => {\n      internals.text = newText;\n    }\n  });\n}\nconst IGNORE = Symbol('ignore');\nfunction updateProps(component, newProps, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const {\n    internalProps: currentProps,\n    externalProps: currentExternalProps\n  } = internals;\n  const normalizedNewProps = {};\n  const hotSwapFunctions = [];\n  let hasRemoteChange = false;\n  for (const key of Object.keys(newProps)) {\n    // See notes above for why we treat `children` as a reserved prop.\n    if (key === 'children') continue;\n    const currentExternalValue = currentExternalProps[key];\n    const newExternalValue = newProps[key];\n    const currentValue = currentProps[key];\n    const newValue = serializeProp(newExternalValue); // Bail out if we have equal, primitive types\n\n    if (currentValue === newValue && (newValue == null || typeof newValue !== 'object')) {\n      continue;\n    }\n    const [value, hotSwaps] = tryHotSwappingValues(currentValue, newValue);\n    if (hotSwaps) {\n      hotSwapFunctions.push(...hotSwaps);\n    }\n    if (value === IGNORE) continue;\n    hasRemoteChange = true;\n    normalizedNewProps[key] = value;\n    if (utilities.isRemoteFragment(currentExternalValue)) {\n      removeNodeFromContainer(currentExternalValue, rootInternals);\n    }\n    if (utilities.isRemoteFragment(newExternalValue)) {\n      moveNodeToContainer(component, newExternalValue, rootInternals);\n    }\n  }\n  return perform(component, rootInternals, {\n    remote: channel => {\n      if (hasRemoteChange) {\n        channel(types.ACTION_UPDATE_PROPS, component.id, normalizedNewProps);\n      }\n    },\n    local: () => {\n      const mergedExternalProps = {\n        ...currentExternalProps,\n        ...newProps\n      };\n      internals.externalProps = strict ? Object.freeze(mergedExternalProps) : mergedExternalProps;\n      internals.internalProps = {\n        ...internals.internalProps,\n        ...normalizedNewProps\n      };\n      for (const [hotSwappable, newValue] of hotSwapFunctions) {\n        hotSwappable[FUNCTION_CURRENT_IMPLEMENTATION_KEY] = newValue;\n      }\n    }\n  });\n} // Imagine the following remote-ui components we might render in a remote context:\n//\n// const root = createRemoteRoot();\n// const {value, onChange, onPress} = getPropsForValue();\n//\n// const textField = root.createComponent('TextField', {value, onChange});\n// const button = root.createComponent('Button', {onPress});\n//\n// root.append(textField);\n// root.append(button);\n//\n// function getPropsForValue(value = '') {\n//   return {\n//     value,\n//     onChange: () => {\n//       const {value, onChange, onPress} = getPropsForValue();\n//       textField.updateProps({value, onChange});\n//       button.updateProps({onPress});\n//     },\n//     onPress: () => console.log(value),\n//   };\n// }\n//\n//\n// In this example, assume that the `TextField` `onChange` prop is run on blur.\n// If this were running on the host, the following steps would happen if you pressed\n// on the button:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value, which\n//    then calls `setValue()` with the updated value.\n// 2. We synchronously update the `value`, `onChange`, and `onPress` props to point at\n//    the most current `value`.\n// 3. Handling blur is finished, so the browser now handles the click by calling the\n//    (newly-updated) `Button` `onPress()`, which logs out the new value.\n//\n// Because remote-ui reproduces a UI tree asynchronously from the remote context, the\n// steps above run in a different order:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value.\n// 2. Handling blur is finished **from the perspective of the main thread**, so the\n//    browser now handles the click by calling the (original) `Button` `onPress()`, which\n//    logs out the **initial** value.\n// 3. In the remote context, we receive the `onChange()` call, which calls updates the props\n//    on the `Button` and `TextField` to be based on the new `value`, but by now it’s\n//    already too late for `onPress` — the old version has already been called!\n//\n// As you can see, the timing issue introduced by the asynchronous nature of remote-ui\n// can cause “old props” to be called from the main thread. This example may seem like\n// an unusual pattern, and it is if you are using `@remote-ui/core` directly; you’d generally\n// keep a mutable reference to the state, instead of closing over the state with new props.\n// However, abstractions on top of `@remote-ui/core`, like the React reconciler in\n// `@remote-ui/react`, work almost entirely by closing over state, so this issue is\n// much more common with those declarative libraries.\n//\n// To protect against this, we handle function props a bit differently. When we have a\n// function prop, we replace it with a new function that calls the original. However,\n// we make the original mutable, by making it a property on the function itself. When\n// this function subsequently updates, we don’t send the update to the main thread (as\n// we just saw, this can often be \"too late\" to be of any use). Instead, we swap out\n// the mutable reference to the current implementation of the function prop, which can\n// be done synchronously. In the example above, this would all happen synchronously in\n// the remote context; in our handling of `TextField onChange()`, we update `Button onPress()`,\n// and swap out the implementations. Now, when the main thread attempts to call `Button onPress()`,\n// it instead calls our wrapper around the function, which can refer to, and call, the\n// most recently-applied implementation, instead of directly calling the old implementation.\n\nfunction tryHotSwappingValues(currentValue, newValue, seen = new Set()) {\n  if (seen.has(currentValue)) {\n    return [IGNORE];\n  }\n  seen.add(currentValue);\n  if (typeof currentValue === 'function' && FUNCTION_CURRENT_IMPLEMENTATION_KEY in currentValue) {\n    const result = [typeof newValue === 'function' ? IGNORE : makeValueHotSwappable(newValue), [[currentValue, newValue]]];\n    return result;\n  }\n  if (Array.isArray(currentValue)) {\n    const result = tryHotSwappingArrayValues(currentValue, newValue, seen);\n    return result;\n  }\n  if (rpc.isBasicObject(currentValue) && !utilities.isRemoteFragment(currentValue)) {\n    const result = tryHotSwappingObjectValues(currentValue, newValue, seen);\n    return result;\n  }\n  const result = [currentValue === newValue ? IGNORE : newValue];\n  return result;\n}\nfunction makeValueHotSwappable(value, seen = new Map()) {\n  const seenValue = seen.get(value);\n  if (seenValue) return seenValue;\n  if (utilities.isRemoteFragment(value)) {\n    seen.set(value, value);\n    return value;\n  }\n  if (Array.isArray(value)) {\n    const result = [];\n    seen.set(value, result);\n    for (const nested of value) {\n      result.push(makeValueHotSwappable(nested, seen));\n    }\n    return result;\n  }\n  if (rpc.isBasicObject(value)) {\n    const result = {};\n    seen.set(value, result);\n    for (const key of Object.keys(value)) {\n      result[key] = makeValueHotSwappable(value[key], seen);\n    }\n    return result;\n  }\n  if (typeof value === 'function') {\n    const wrappedFunction = (...args) => {\n      return wrappedFunction[FUNCTION_CURRENT_IMPLEMENTATION_KEY](...args);\n    };\n    Object.defineProperty(wrappedFunction, FUNCTION_CURRENT_IMPLEMENTATION_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value\n    });\n    seen.set(value, wrappedFunction);\n    return wrappedFunction;\n  }\n  seen.set(value, value);\n  return value;\n}\nfunction collectNestedHotSwappableValues(value, seen = new Set()) {\n  if (seen.has(value)) return undefined;\n  seen.add(value);\n  if (Array.isArray(value)) {\n    return value.reduce((all, element) => {\n      const nested = collectNestedHotSwappableValues(element, seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n  if (rpc.isBasicObject(value)) {\n    return Object.keys(value).reduce((all, key) => {\n      const nested = collectNestedHotSwappableValues(value[key], seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n  if (typeof value === 'function') {\n    return FUNCTION_CURRENT_IMPLEMENTATION_KEY in value ? [value] : undefined;\n  }\n  return undefined;\n}\nfunction remove(child) {\n  var _child$parent;\n  (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child);\n}\nfunction append(container, children, internals, rootInternals) {\n  for (const child of children) {\n    appendChild(container, child, internals, rootInternals);\n  }\n}\nfunction appendChild(container, child, internals, rootInternals) {\n  var _currentParent$childr;\n  const {\n    nodes,\n    strict\n  } = rootInternals;\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot append a node that was not created by this remote root`);\n  }\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr !== void 0 ? _currentParent$childr : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      channel(types.ACTION_INSERT_CHILD, container.id, existingIndex < 0 ? container.children.length : container.children.length - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n      newChildren.push(child);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\nfunction replaceChildren(container, children, internals, rootInternals) {\n  for (const child of container.children) {\n    removeChild(container, child, internals, rootInternals);\n  }\n  append(container, children, internals, rootInternals);\n} // there is a problem with this, because when multiple children\n// are removed, there is no guarantee the messages will arrive in the\n// order we need them to on the host side (it depends how React\n// calls our reconciler). If it calls with, for example, the removal of\n// the second last item, then the removal of the last item, it will fail\n// because the indexes moved around.\n//\n// Might need to send the removed child ID, or find out if we\n// can collect removals into a single update.\n\nfunction removeChild(container, child, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  return perform(container, rootInternals, {\n    remote: channel => channel(types.ACTION_REMOVE_CHILD, container.id, container.children.indexOf(child)),\n    local: () => {\n      removeNodeFromContainer(child, rootInternals);\n      const newChildren = [...internals.children];\n      newChildren.splice(newChildren.indexOf(child), 1);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\nfunction insertBefore(container, child, before, internals, rootInternals) {\n  var _currentParent$childr2;\n  const {\n    strict,\n    nodes\n  } = rootInternals;\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot insert a node that was not created by this remote root`);\n  }\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr2 = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr2 !== void 0 ? _currentParent$childr2 : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      const beforeIndex = before == null ? container.children.length - 1 : container.children.indexOf(before);\n      channel(types.ACTION_INSERT_CHILD, container.id, beforeIndex < existingIndex || existingIndex < 0 ? beforeIndex : beforeIndex - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n      if (before == null) {\n        newChildren.push(child);\n      } else {\n        newChildren.splice(newChildren.indexOf(before), 0, child);\n      }\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\nfunction normalizeChild(child, root) {\n  return typeof child === 'string' ? root.createText(child) : child;\n}\nfunction moveNodeToContainer(container, node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  const newTop = container.kind === types.KIND_ROOT ? container : tops.get(container);\n  tops.set(node, newTop);\n  parents.set(node, container);\n  moveFragmentToContainer(node, rootInternals);\n  allDescendants(node, descendant => {\n    tops.set(descendant, newTop);\n    moveFragmentToContainer(descendant, rootInternals);\n  });\n}\nfunction moveFragmentToContainer(node, rootInternals) {\n  if (node.kind !== types.KIND_COMPONENT) return;\n  const props = node.props;\n  if (!props) return;\n  Object.values(props).forEach(prop => {\n    if (!utilities.isRemoteFragment(prop)) return;\n    moveNodeToContainer(node, prop, rootInternals);\n  });\n}\nfunction removeNodeFromContainer(node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  tops.delete(node);\n  parents.delete(node);\n  allDescendants(node, descendant => {\n    tops.delete(descendant);\n    removeFragmentFromContainer(descendant, rootInternals);\n  });\n  removeFragmentFromContainer(node, rootInternals);\n}\nfunction removeFragmentFromContainer(node, rootInternals) {\n  if (node.kind !== types.KIND_COMPONENT) return;\n  const props = node.remoteProps;\n  for (const key of Object.keys(props !== null && props !== void 0 ? props : {})) {\n    const prop = props[key];\n    if (!utilities.isRemoteFragment(prop)) continue;\n    removeNodeFromContainer(prop, rootInternals);\n  }\n}\nfunction makePartOfTree(node, {\n  parents,\n  tops,\n  nodes\n}) {\n  nodes.add(node);\n  Object.defineProperty(node, 'parent', {\n    get() {\n      return parents.get(node);\n    },\n    configurable: true,\n    enumerable: true\n  });\n  Object.defineProperty(node, 'top', {\n    get() {\n      return tops.get(node);\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\nfunction serializeChild(value) {\n  return value.kind === types.KIND_TEXT ? {\n    id: value.id,\n    kind: value.kind,\n    text: value.text\n  } : {\n    id: value.id,\n    kind: value.kind,\n    type: value.type,\n    props: value.remoteProps,\n    children: value.children.map(child => serializeChild(child))\n  };\n}\nfunction serializeProp(prop) {\n  if (utilities.isRemoteFragment(prop)) {\n    return serializeFragment(prop);\n  }\n  return prop;\n}\nfunction serializeFragment(value) {\n  return {\n    id: value.id,\n    kind: value.kind,\n    get children() {\n      return value.children.map(child => serializeChild(child));\n    }\n  };\n}\nfunction getCurrentInternals(currentParent, rootInternals) {\n  if (currentParent.kind === types.KIND_ROOT) {\n    return rootInternals;\n  }\n  if (currentParent.kind === types.KIND_FRAGMENT) {\n    return rootInternals.fragments.get(currentParent);\n  }\n  return rootInternals.components.get(currentParent);\n}\nfunction makeRemote(value, id, root) {\n  Object.defineProperty(value, 'id', {\n    value: id,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(value, 'root', {\n    value: root,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\nfunction tryHotSwappingObjectValues(currentValue, newValue, seen) {\n  if (!rpc.isBasicObject(newValue)) {\n    var _collectNestedHotSwap;\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap === void 0 ? void 0 : _collectNestedHotSwap.map(hotSwappable => [hotSwappable, undefined])];\n  }\n  let hasChanged = false;\n  const hotSwaps = [];\n  const normalizedNewValue = {}; // eslint-disable-next-line guard-for-in\n\n  for (const key in currentValue) {\n    const currentObjectValue = currentValue[key];\n    if (!(key in newValue)) {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentObjectValue);\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n    const newObjectValue = newValue[key];\n    const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentObjectValue, newObjectValue, seen);\n    if (elementHotSwaps) {\n      hotSwaps.push(...elementHotSwaps);\n    }\n    if (updatedValue !== IGNORE) {\n      hasChanged = true;\n      normalizedNewValue[key] = updatedValue;\n    }\n  }\n  for (const key in newValue) {\n    if (key in normalizedNewValue) continue;\n    hasChanged = true;\n    normalizedNewValue[key] = makeValueHotSwappable(newValue[key]);\n  }\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\nfunction tryHotSwappingArrayValues(currentValue, newValue, seen) {\n  if (!Array.isArray(newValue)) {\n    var _collectNestedHotSwap2;\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap2 = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap2 === void 0 ? void 0 : _collectNestedHotSwap2.map(hotSwappable => [hotSwappable, undefined])];\n  }\n  let hasChanged = false;\n  const hotSwaps = [];\n  const newLength = newValue.length;\n  const currentLength = currentValue.length;\n  const maxLength = Math.max(currentLength, newLength);\n  const normalizedNewValue = [];\n  for (let i = 0; i < maxLength; i++) {\n    const currentArrayValue = currentValue[i];\n    const newArrayValue = newValue[i];\n    if (i < newLength) {\n      if (i >= currentLength) {\n        hasChanged = true;\n        normalizedNewValue[i] = makeValueHotSwappable(newArrayValue);\n        continue;\n      }\n      const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentArrayValue, newArrayValue, seen);\n      if (elementHotSwaps) hotSwaps.push(...elementHotSwaps);\n      if (updatedValue === IGNORE) {\n        normalizedNewValue[i] = currentArrayValue;\n        continue;\n      }\n      hasChanged = true;\n      normalizedNewValue[i] = updatedValue;\n    } else {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentArrayValue);\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n  }\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\nexports.createRemoteRoot = createRemoteRoot;","map":{"version":3,"names":["Object","defineProperty","exports","value","rpc","require","types","utilities","FUNCTION_CURRENT_IMPLEMENTATION_KEY","EMPTY_OBJECT","EMPTY_ARRAY","createRemoteRoot","channel","strict","components","currentId","rootInternals","mounted","children","nodes","WeakSet","parents","WeakMap","tops","fragments","freeze","remoteRoot","kind","KIND_ROOT","options","createComponent","type","rest","indexOf","Error","initialProps","initialChildren","moreChildren","normalizedInitialProps","normalizedInitialChildren","normalizedInternalProps","key","keys","makeValueHotSwappable","serializeProp","Array","isArray","child","push","normalizeChild","id","internals","externalProps","internalProps","component","KIND_COMPONENT","props","remoteProps","remove","updateProps","newProps","append","map","appendChild","removeChild","replaceChildren","insertBefore","before","insertChildBefore","set","configurable","writable","enumerable","makePartOfTree","makeRemote","moveNodeToContainer","createText","content","text","update","newText","updateText","KIND_TEXT","createFragment","fragment","KIND_FRAGMENT","mount","Promise","resolve","ACTION_MOUNT","serializeChild","connected","element","_tops$get","get","allDescendants","withEach","recurse","perform","remote","local","ACTION_UPDATE_TEXT","IGNORE","Symbol","currentProps","currentExternalProps","normalizedNewProps","hotSwapFunctions","hasRemoteChange","currentExternalValue","newExternalValue","currentValue","newValue","hotSwaps","tryHotSwappingValues","isRemoteFragment","removeNodeFromContainer","ACTION_UPDATE_PROPS","mergedExternalProps","hotSwappable","seen","Set","has","add","result","tryHotSwappingArrayValues","isBasicObject","tryHotSwappingObjectValues","Map","seenValue","nested","wrappedFunction","args","collectNestedHotSwappableValues","undefined","reduce","all","_child$parent","parent","container","_currentParent$childr","currentParent","existingIndex","ACTION_INSERT_CHILD","length","newChildren","currentInternals","getCurrentInternals","currentChildren","splice","ACTION_REMOVE_CHILD","_currentParent$childr2","beforeIndex","root","node","newTop","moveFragmentToContainer","descendant","values","forEach","prop","delete","removeFragmentFromContainer","serializeFragment","_collectNestedHotSwap","hasChanged","normalizedNewValue","currentObjectValue","nestedHotSwappables","newObjectValue","updatedValue","elementHotSwaps","_collectNestedHotSwap2","newLength","currentLength","maxLength","Math","max","i","currentArrayValue","newArrayValue"],"sources":["/Users/raghavvherugu/Desktop/Projects/name/Jila/node_modules/@remote-ui/core/build/cjs/root.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar rpc = require('@remote-ui/rpc');\nvar types = require('./types.js');\nvar utilities = require('./utilities.js');\n\nconst FUNCTION_CURRENT_IMPLEMENTATION_KEY = '__current';\nconst EMPTY_OBJECT = {};\nconst EMPTY_ARRAY = [];\nfunction createRemoteRoot(channel, {\n  strict = true,\n  components\n} = {}) {\n  let currentId = 0;\n  const rootInternals = {\n    strict,\n    mounted: false,\n    channel,\n    children: EMPTY_ARRAY,\n    nodes: new WeakSet(),\n    parents: new WeakMap(),\n    tops: new WeakMap(),\n    components: new WeakMap(),\n    fragments: new WeakMap()\n  };\n  if (strict) Object.freeze(components);\n  const remoteRoot = {\n    kind: types.KIND_ROOT,\n    options: strict ? Object.freeze({\n      strict,\n      components\n    }) : {\n      strict,\n      components\n    },\n\n    get children() {\n      return rootInternals.children;\n    },\n\n    createComponent(type, ...rest) {\n      if (components && components.indexOf(type) < 0) {\n        throw new Error(`Unsupported component: ${type}`);\n      }\n\n      const [initialProps, initialChildren, ...moreChildren] = rest;\n      const normalizedInitialProps = initialProps !== null && initialProps !== void 0 ? initialProps : {};\n      const normalizedInitialChildren = [];\n      const normalizedInternalProps = {};\n\n      if (initialProps) {\n        for (const key of Object.keys(initialProps)) {\n          // \"children\" as a prop can be extremely confusing with the \"children\" of\n          // a component. In React, a \"child\" can be anything, but once it reaches\n          // a host environment (like this remote `Root`), we want \"children\" to have\n          // only one meaning: the actual, resolved children components and text.\n          //\n          // To enforce this, we delete any prop named \"children\". We don’t take a copy\n          // of the props for performance, so a user calling this function must do so\n          // with an object that can handle being mutated.\n          if (key === 'children') continue;\n          normalizedInternalProps[key] = makeValueHotSwappable(serializeProp(initialProps[key]));\n        }\n      }\n\n      if (initialChildren) {\n        if (Array.isArray(initialChildren)) {\n          for (const child of initialChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        } else {\n          normalizedInitialChildren.push(normalizeChild(initialChildren, remoteRoot)); // The complex tuple type of `rest` makes it so `moreChildren` is\n          // incorrectly inferred as potentially being the props of the component,\n          // lazy casting since we know it will be an array of child elements\n          // (or empty).\n\n          for (const child of moreChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        }\n      }\n\n      const id = `${currentId++}`;\n      const internals = {\n        externalProps: strict ? Object.freeze(normalizedInitialProps) : normalizedInitialProps,\n        internalProps: normalizedInternalProps,\n        children: strict ? Object.freeze(normalizedInitialChildren) : normalizedInitialChildren\n      };\n      const component = {\n        kind: types.KIND_COMPONENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        get props() {\n          return internals.externalProps;\n        },\n\n        get remoteProps() {\n          return internals.internalProps;\n        },\n\n        remove: () => remove(component),\n        updateProps: newProps => updateProps(component, newProps, internals, rootInternals),\n        append: (...children) => append(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(component, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(component, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually, which we do below. If we just `as any`\n        // the whole object, we lose the implicit argument types for the\n        // methods above.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.components.set(component, internals);\n      Object.defineProperty(component, 'type', {\n        value: type,\n        configurable: false,\n        writable: false,\n        enumerable: true\n      });\n      makePartOfTree(component, rootInternals);\n      makeRemote(component, id, remoteRoot);\n\n      for (const child of internals.children) {\n        moveNodeToContainer(component, child, rootInternals);\n      }\n\n      return component;\n    },\n\n    createText(content = '') {\n      const id = `${currentId++}`;\n      const internals = {\n        text: content\n      };\n\n      const update = newText => updateText(text, newText, internals, rootInternals);\n\n      const text = {\n        kind: types.KIND_TEXT,\n\n        get text() {\n          return internals.text;\n        },\n\n        update,\n        updateText: update,\n        remove: () => remove(text),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      makePartOfTree(text, rootInternals);\n      makeRemote(text, id, remoteRoot);\n      return text;\n    },\n\n    createFragment() {\n      const id = `${currentId++}`;\n      const internals = {\n        children: strict ? Object.freeze([]) : []\n      };\n      const fragment = {\n        kind: types.KIND_FRAGMENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        append: (...children) => append(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(fragment, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(fragment, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.fragments.set(fragment, internals);\n      makePartOfTree(fragment, rootInternals);\n      makeRemote(fragment, id, remoteRoot);\n      return fragment;\n    },\n\n    append: (...children) => append(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    appendChild: child => appendChild(remoteRoot, normalizeChild(child, remoteRoot), rootInternals, rootInternals),\n    replaceChildren: (...children) => replaceChildren(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    removeChild: child => removeChild(remoteRoot, child, rootInternals, rootInternals),\n    insertBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n    insertChildBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n\n    mount() {\n      if (rootInternals.mounted) return Promise.resolve();\n      rootInternals.mounted = true;\n      return Promise.resolve(channel(types.ACTION_MOUNT, rootInternals.children.map(serializeChild)));\n    }\n\n  };\n  return remoteRoot;\n}\n\nfunction connected(element, {\n  tops\n}) {\n  var _tops$get;\n\n  return ((_tops$get = tops.get(element)) === null || _tops$get === void 0 ? void 0 : _tops$get.kind) === types.KIND_ROOT;\n}\n\nfunction allDescendants(element, withEach) {\n  const recurse = element => {\n    if ('children' in element) {\n      for (const child of element.children) {\n        withEach(child);\n        recurse(child);\n      }\n    }\n  };\n\n  recurse(element);\n}\n\nfunction perform(element, rootInternals, {\n  remote,\n  local\n}) {\n  const {\n    mounted,\n    channel\n  } = rootInternals;\n\n  if (mounted && (element.kind === types.KIND_ROOT || connected(element, rootInternals))) {\n    // should only create context once async queue is cleared\n    remote(channel); // technically, we should be waiting for the remote update to apply,\n    // then apply it locally. The implementation below is too naive because\n    // it allows local updates to get out of sync with remote ones.\n    // if (remoteResult == null || !('then' in remoteResult)) {\n    //   local();\n    //   return;\n    // } else {\n    //   return remoteResult.then(() => {\n    //     local();\n    //   });\n    // }\n  }\n\n  local();\n}\n\nfunction updateText(text, newText, internals, rootInternals) {\n  return perform(text, rootInternals, {\n    remote: channel => channel(types.ACTION_UPDATE_TEXT, text.id, newText),\n    local: () => {\n      internals.text = newText;\n    }\n  });\n}\n\nconst IGNORE = Symbol('ignore');\n\nfunction updateProps(component, newProps, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const {\n    internalProps: currentProps,\n    externalProps: currentExternalProps\n  } = internals;\n  const normalizedNewProps = {};\n  const hotSwapFunctions = [];\n  let hasRemoteChange = false;\n\n  for (const key of Object.keys(newProps)) {\n    // See notes above for why we treat `children` as a reserved prop.\n    if (key === 'children') continue;\n    const currentExternalValue = currentExternalProps[key];\n    const newExternalValue = newProps[key];\n    const currentValue = currentProps[key];\n    const newValue = serializeProp(newExternalValue); // Bail out if we have equal, primitive types\n\n    if (currentValue === newValue && (newValue == null || typeof newValue !== 'object')) {\n      continue;\n    }\n\n    const [value, hotSwaps] = tryHotSwappingValues(currentValue, newValue);\n\n    if (hotSwaps) {\n      hotSwapFunctions.push(...hotSwaps);\n    }\n\n    if (value === IGNORE) continue;\n    hasRemoteChange = true;\n    normalizedNewProps[key] = value;\n\n    if (utilities.isRemoteFragment(currentExternalValue)) {\n      removeNodeFromContainer(currentExternalValue, rootInternals);\n    }\n\n    if (utilities.isRemoteFragment(newExternalValue)) {\n      moveNodeToContainer(component, newExternalValue, rootInternals);\n    }\n  }\n\n  return perform(component, rootInternals, {\n    remote: channel => {\n      if (hasRemoteChange) {\n        channel(types.ACTION_UPDATE_PROPS, component.id, normalizedNewProps);\n      }\n    },\n    local: () => {\n      const mergedExternalProps = { ...currentExternalProps,\n        ...newProps\n      };\n      internals.externalProps = strict ? Object.freeze(mergedExternalProps) : mergedExternalProps;\n      internals.internalProps = { ...internals.internalProps,\n        ...normalizedNewProps\n      };\n\n      for (const [hotSwappable, newValue] of hotSwapFunctions) {\n        hotSwappable[FUNCTION_CURRENT_IMPLEMENTATION_KEY] = newValue;\n      }\n    }\n  });\n} // Imagine the following remote-ui components we might render in a remote context:\n//\n// const root = createRemoteRoot();\n// const {value, onChange, onPress} = getPropsForValue();\n//\n// const textField = root.createComponent('TextField', {value, onChange});\n// const button = root.createComponent('Button', {onPress});\n//\n// root.append(textField);\n// root.append(button);\n//\n// function getPropsForValue(value = '') {\n//   return {\n//     value,\n//     onChange: () => {\n//       const {value, onChange, onPress} = getPropsForValue();\n//       textField.updateProps({value, onChange});\n//       button.updateProps({onPress});\n//     },\n//     onPress: () => console.log(value),\n//   };\n// }\n//\n//\n// In this example, assume that the `TextField` `onChange` prop is run on blur.\n// If this were running on the host, the following steps would happen if you pressed\n// on the button:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value, which\n//    then calls `setValue()` with the updated value.\n// 2. We synchronously update the `value`, `onChange`, and `onPress` props to point at\n//    the most current `value`.\n// 3. Handling blur is finished, so the browser now handles the click by calling the\n//    (newly-updated) `Button` `onPress()`, which logs out the new value.\n//\n// Because remote-ui reproduces a UI tree asynchronously from the remote context, the\n// steps above run in a different order:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value.\n// 2. Handling blur is finished **from the perspective of the main thread**, so the\n//    browser now handles the click by calling the (original) `Button` `onPress()`, which\n//    logs out the **initial** value.\n// 3. In the remote context, we receive the `onChange()` call, which calls updates the props\n//    on the `Button` and `TextField` to be based on the new `value`, but by now it’s\n//    already too late for `onPress` — the old version has already been called!\n//\n// As you can see, the timing issue introduced by the asynchronous nature of remote-ui\n// can cause “old props” to be called from the main thread. This example may seem like\n// an unusual pattern, and it is if you are using `@remote-ui/core` directly; you’d generally\n// keep a mutable reference to the state, instead of closing over the state with new props.\n// However, abstractions on top of `@remote-ui/core`, like the React reconciler in\n// `@remote-ui/react`, work almost entirely by closing over state, so this issue is\n// much more common with those declarative libraries.\n//\n// To protect against this, we handle function props a bit differently. When we have a\n// function prop, we replace it with a new function that calls the original. However,\n// we make the original mutable, by making it a property on the function itself. When\n// this function subsequently updates, we don’t send the update to the main thread (as\n// we just saw, this can often be \"too late\" to be of any use). Instead, we swap out\n// the mutable reference to the current implementation of the function prop, which can\n// be done synchronously. In the example above, this would all happen synchronously in\n// the remote context; in our handling of `TextField onChange()`, we update `Button onPress()`,\n// and swap out the implementations. Now, when the main thread attempts to call `Button onPress()`,\n// it instead calls our wrapper around the function, which can refer to, and call, the\n// most recently-applied implementation, instead of directly calling the old implementation.\n\n\nfunction tryHotSwappingValues(currentValue, newValue, seen = new Set()) {\n  if (seen.has(currentValue)) {\n    return [IGNORE];\n  }\n\n  seen.add(currentValue);\n\n  if (typeof currentValue === 'function' && FUNCTION_CURRENT_IMPLEMENTATION_KEY in currentValue) {\n    const result = [typeof newValue === 'function' ? IGNORE : makeValueHotSwappable(newValue), [[currentValue, newValue]]];\n    return result;\n  }\n\n  if (Array.isArray(currentValue)) {\n    const result = tryHotSwappingArrayValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  if (rpc.isBasicObject(currentValue) && !utilities.isRemoteFragment(currentValue)) {\n    const result = tryHotSwappingObjectValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  const result = [currentValue === newValue ? IGNORE : newValue];\n  return result;\n}\n\nfunction makeValueHotSwappable(value, seen = new Map()) {\n  const seenValue = seen.get(value);\n  if (seenValue) return seenValue;\n\n  if (utilities.isRemoteFragment(value)) {\n    seen.set(value, value);\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    const result = [];\n    seen.set(value, result);\n\n    for (const nested of value) {\n      result.push(makeValueHotSwappable(nested, seen));\n    }\n\n    return result;\n  }\n\n  if (rpc.isBasicObject(value)) {\n    const result = {};\n    seen.set(value, result);\n\n    for (const key of Object.keys(value)) {\n      result[key] = makeValueHotSwappable(value[key], seen);\n    }\n\n    return result;\n  }\n\n  if (typeof value === 'function') {\n    const wrappedFunction = (...args) => {\n      return wrappedFunction[FUNCTION_CURRENT_IMPLEMENTATION_KEY](...args);\n    };\n\n    Object.defineProperty(wrappedFunction, FUNCTION_CURRENT_IMPLEMENTATION_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value\n    });\n    seen.set(value, wrappedFunction);\n    return wrappedFunction;\n  }\n\n  seen.set(value, value);\n  return value;\n}\n\nfunction collectNestedHotSwappableValues(value, seen = new Set()) {\n  if (seen.has(value)) return undefined;\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.reduce((all, element) => {\n      const nested = collectNestedHotSwappableValues(element, seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (rpc.isBasicObject(value)) {\n    return Object.keys(value).reduce((all, key) => {\n      const nested = collectNestedHotSwappableValues(value[key], seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (typeof value === 'function') {\n    return FUNCTION_CURRENT_IMPLEMENTATION_KEY in value ? [value] : undefined;\n  }\n\n  return undefined;\n}\n\nfunction remove(child) {\n  var _child$parent;\n\n  (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child);\n}\n\nfunction append(container, children, internals, rootInternals) {\n  for (const child of children) {\n    appendChild(container, child, internals, rootInternals);\n  }\n}\n\nfunction appendChild(container, child, internals, rootInternals) {\n  var _currentParent$childr;\n\n  const {\n    nodes,\n    strict\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot append a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr !== void 0 ? _currentParent$childr : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      channel(types.ACTION_INSERT_CHILD, container.id, existingIndex < 0 ? container.children.length : container.children.length - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      newChildren.push(child);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction replaceChildren(container, children, internals, rootInternals) {\n  for (const child of container.children) {\n    removeChild(container, child, internals, rootInternals);\n  }\n\n  append(container, children, internals, rootInternals);\n} // there is a problem with this, because when multiple children\n// are removed, there is no guarantee the messages will arrive in the\n// order we need them to on the host side (it depends how React\n// calls our reconciler). If it calls with, for example, the removal of\n// the second last item, then the removal of the last item, it will fail\n// because the indexes moved around.\n//\n// Might need to send the removed child ID, or find out if we\n// can collect removals into a single update.\n\n\nfunction removeChild(container, child, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  return perform(container, rootInternals, {\n    remote: channel => channel(types.ACTION_REMOVE_CHILD, container.id, container.children.indexOf(child)),\n    local: () => {\n      removeNodeFromContainer(child, rootInternals);\n      const newChildren = [...internals.children];\n      newChildren.splice(newChildren.indexOf(child), 1);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction insertBefore(container, child, before, internals, rootInternals) {\n  var _currentParent$childr2;\n\n  const {\n    strict,\n    nodes\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot insert a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr2 = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr2 !== void 0 ? _currentParent$childr2 : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      const beforeIndex = before == null ? container.children.length - 1 : container.children.indexOf(before);\n      channel(types.ACTION_INSERT_CHILD, container.id, beforeIndex < existingIndex || existingIndex < 0 ? beforeIndex : beforeIndex - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      if (before == null) {\n        newChildren.push(child);\n      } else {\n        newChildren.splice(newChildren.indexOf(before), 0, child);\n      }\n\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction normalizeChild(child, root) {\n  return typeof child === 'string' ? root.createText(child) : child;\n}\n\nfunction moveNodeToContainer(container, node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  const newTop = container.kind === types.KIND_ROOT ? container : tops.get(container);\n  tops.set(node, newTop);\n  parents.set(node, container);\n  moveFragmentToContainer(node, rootInternals);\n  allDescendants(node, descendant => {\n    tops.set(descendant, newTop);\n    moveFragmentToContainer(descendant, rootInternals);\n  });\n}\n\nfunction moveFragmentToContainer(node, rootInternals) {\n  if (node.kind !== types.KIND_COMPONENT) return;\n  const props = node.props;\n  if (!props) return;\n  Object.values(props).forEach(prop => {\n    if (!utilities.isRemoteFragment(prop)) return;\n    moveNodeToContainer(node, prop, rootInternals);\n  });\n}\n\nfunction removeNodeFromContainer(node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  tops.delete(node);\n  parents.delete(node);\n  allDescendants(node, descendant => {\n    tops.delete(descendant);\n    removeFragmentFromContainer(descendant, rootInternals);\n  });\n  removeFragmentFromContainer(node, rootInternals);\n}\n\nfunction removeFragmentFromContainer(node, rootInternals) {\n  if (node.kind !== types.KIND_COMPONENT) return;\n  const props = node.remoteProps;\n\n  for (const key of Object.keys(props !== null && props !== void 0 ? props : {})) {\n    const prop = props[key];\n    if (!utilities.isRemoteFragment(prop)) continue;\n    removeNodeFromContainer(prop, rootInternals);\n  }\n}\n\nfunction makePartOfTree(node, {\n  parents,\n  tops,\n  nodes\n}) {\n  nodes.add(node);\n  Object.defineProperty(node, 'parent', {\n    get() {\n      return parents.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n  Object.defineProperty(node, 'top', {\n    get() {\n      return tops.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction serializeChild(value) {\n  return value.kind === types.KIND_TEXT ? {\n    id: value.id,\n    kind: value.kind,\n    text: value.text\n  } : {\n    id: value.id,\n    kind: value.kind,\n    type: value.type,\n    props: value.remoteProps,\n    children: value.children.map(child => serializeChild(child))\n  };\n}\n\nfunction serializeProp(prop) {\n  if (utilities.isRemoteFragment(prop)) {\n    return serializeFragment(prop);\n  }\n\n  return prop;\n}\n\nfunction serializeFragment(value) {\n  return {\n    id: value.id,\n    kind: value.kind,\n\n    get children() {\n      return value.children.map(child => serializeChild(child));\n    }\n\n  };\n}\n\nfunction getCurrentInternals(currentParent, rootInternals) {\n  if (currentParent.kind === types.KIND_ROOT) {\n    return rootInternals;\n  }\n\n  if (currentParent.kind === types.KIND_FRAGMENT) {\n    return rootInternals.fragments.get(currentParent);\n  }\n\n  return rootInternals.components.get(currentParent);\n}\n\nfunction makeRemote(value, id, root) {\n  Object.defineProperty(value, 'id', {\n    value: id,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(value, 'root', {\n    value: root,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\n\nfunction tryHotSwappingObjectValues(currentValue, newValue, seen) {\n  if (!rpc.isBasicObject(newValue)) {\n    var _collectNestedHotSwap;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap === void 0 ? void 0 : _collectNestedHotSwap.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const normalizedNewValue = {}; // eslint-disable-next-line guard-for-in\n\n  for (const key in currentValue) {\n    const currentObjectValue = currentValue[key];\n\n    if (!(key in newValue)) {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentObjectValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n\n    const newObjectValue = newValue[key];\n    const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentObjectValue, newObjectValue, seen);\n\n    if (elementHotSwaps) {\n      hotSwaps.push(...elementHotSwaps);\n    }\n\n    if (updatedValue !== IGNORE) {\n      hasChanged = true;\n      normalizedNewValue[key] = updatedValue;\n    }\n  }\n\n  for (const key in newValue) {\n    if (key in normalizedNewValue) continue;\n    hasChanged = true;\n    normalizedNewValue[key] = makeValueHotSwappable(newValue[key]);\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nfunction tryHotSwappingArrayValues(currentValue, newValue, seen) {\n  if (!Array.isArray(newValue)) {\n    var _collectNestedHotSwap2;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap2 = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap2 === void 0 ? void 0 : _collectNestedHotSwap2.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const newLength = newValue.length;\n  const currentLength = currentValue.length;\n  const maxLength = Math.max(currentLength, newLength);\n  const normalizedNewValue = [];\n\n  for (let i = 0; i < maxLength; i++) {\n    const currentArrayValue = currentValue[i];\n    const newArrayValue = newValue[i];\n\n    if (i < newLength) {\n      if (i >= currentLength) {\n        hasChanged = true;\n        normalizedNewValue[i] = makeValueHotSwappable(newArrayValue);\n        continue;\n      }\n\n      const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentArrayValue, newArrayValue, seen);\n      if (elementHotSwaps) hotSwaps.push(...elementHotSwaps);\n\n      if (updatedValue === IGNORE) {\n        normalizedNewValue[i] = currentArrayValue;\n        continue;\n      }\n\n      hasChanged = true;\n      normalizedNewValue[i] = updatedValue;\n    } else {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentArrayValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nexports.createRemoteRoot = createRemoteRoot;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}