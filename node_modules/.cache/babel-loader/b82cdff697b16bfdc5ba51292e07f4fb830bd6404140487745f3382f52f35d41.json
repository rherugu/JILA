{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar constants = require('./constants.js');\nfunction fromIframe(target, {\n  terminate: shouldTerminate = true,\n  targetOrigin = '*'\n} = {}) {\n  var _target$contentWindow;\n  if (typeof window === 'undefined') {\n    throw new Error(`You can only run fromIframe() in a browser context, but no window was found.`);\n  } // We need to store the listener, because we wrap it to do some origin checking. Ideally,\n  // we’d instead store an `AbortController`, and use its signal to cancel the listeners,\n  // but that isn’t widely supported.\n\n  const listenerMap = new WeakMap();\n  let resolveIFrameReadyPromise;\n  function onMessage(event) {\n    if (event.source !== target.contentWindow) return;\n    if (event.data === constants.READY_MESSAGE_KEY) {\n      window.removeEventListener('message', onMessage);\n      resolveIFrameReadyPromise();\n    }\n  }\n  (_target$contentWindow = target.contentWindow) === null || _target$contentWindow === void 0 ? void 0 : _target$contentWindow.postMessage(constants.READY_MESSAGE_KEY, targetOrigin);\n  const iframeReadyPromise = new Promise(resolve => {\n    resolveIFrameReadyPromise = resolve;\n    window.addEventListener('message', onMessage);\n  });\n  return {\n    async postMessage(message, transfer) {\n      var _target$contentWindow2;\n      await iframeReadyPromise;\n      (_target$contentWindow2 = target.contentWindow) === null || _target$contentWindow2 === void 0 ? void 0 : _target$contentWindow2.postMessage(message, targetOrigin, transfer);\n    },\n    addEventListener(event, listener) {\n      const wrappedListener = event => {\n        if (event.source !== target.contentWindow) return;\n        listener(event);\n      };\n      listenerMap.set(listener, wrappedListener);\n      self.addEventListener(event, wrappedListener);\n    },\n    removeEventListener(event, listener) {\n      const wrappedListener = listenerMap.get(listener);\n      if (wrappedListener == null) return;\n      listenerMap.delete(listener);\n      self.removeEventListener(event, wrappedListener);\n    },\n    terminate() {\n      window.removeEventListener('message', onMessage);\n      if (shouldTerminate) target.remove();\n    }\n  };\n}\nexports.fromIframe = fromIframe;","map":{"version":3,"names":["Object","defineProperty","exports","value","constants","require","fromIframe","target","terminate","shouldTerminate","targetOrigin","_target$contentWindow","window","Error","listenerMap","WeakMap","resolveIFrameReadyPromise","onMessage","event","source","contentWindow","data","READY_MESSAGE_KEY","removeEventListener","postMessage","iframeReadyPromise","Promise","resolve","addEventListener","message","transfer","_target$contentWindow2","listener","wrappedListener","set","self","get","delete","remove"],"sources":["/Users/raghavvherugu/Desktop/Projects/name/Jila/node_modules/@remote-ui/rpc/build/cjs/adaptors/iframe-parent.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar constants = require('./constants.js');\n\nfunction fromIframe(target, {\n  terminate: shouldTerminate = true,\n  targetOrigin = '*'\n} = {}) {\n  var _target$contentWindow;\n\n  if (typeof window === 'undefined') {\n    throw new Error(`You can only run fromIframe() in a browser context, but no window was found.`);\n  } // We need to store the listener, because we wrap it to do some origin checking. Ideally,\n  // we’d instead store an `AbortController`, and use its signal to cancel the listeners,\n  // but that isn’t widely supported.\n\n\n  const listenerMap = new WeakMap();\n  let resolveIFrameReadyPromise;\n\n  function onMessage(event) {\n    if (event.source !== target.contentWindow) return;\n\n    if (event.data === constants.READY_MESSAGE_KEY) {\n      window.removeEventListener('message', onMessage);\n      resolveIFrameReadyPromise();\n    }\n  }\n\n  (_target$contentWindow = target.contentWindow) === null || _target$contentWindow === void 0 ? void 0 : _target$contentWindow.postMessage(constants.READY_MESSAGE_KEY, targetOrigin);\n  const iframeReadyPromise = new Promise(resolve => {\n    resolveIFrameReadyPromise = resolve;\n    window.addEventListener('message', onMessage);\n  });\n  return {\n    async postMessage(message, transfer) {\n      var _target$contentWindow2;\n\n      await iframeReadyPromise;\n      (_target$contentWindow2 = target.contentWindow) === null || _target$contentWindow2 === void 0 ? void 0 : _target$contentWindow2.postMessage(message, targetOrigin, transfer);\n    },\n\n    addEventListener(event, listener) {\n      const wrappedListener = event => {\n        if (event.source !== target.contentWindow) return;\n        listener(event);\n      };\n\n      listenerMap.set(listener, wrappedListener);\n      self.addEventListener(event, wrappedListener);\n    },\n\n    removeEventListener(event, listener) {\n      const wrappedListener = listenerMap.get(listener);\n      if (wrappedListener == null) return;\n      listenerMap.delete(listener);\n      self.removeEventListener(event, wrappedListener);\n    },\n\n    terminate() {\n      window.removeEventListener('message', onMessage);\n      if (shouldTerminate) target.remove();\n    }\n\n  };\n}\n\nexports.fromIframe = fromIframe;\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAE7D,IAAIC,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAEzC,SAASC,UAAUA,CAACC,MAAM,EAAE;EAC1BC,SAAS,EAAEC,eAAe,GAAG,IAAI;EACjCC,YAAY,GAAG;AACjB,CAAC,GAAG,CAAC,CAAC,EAAE;EACN,IAAIC,qBAAqB;EAEzB,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACjC,MAAM,IAAIC,KAAK,CAAE,8EAA6E,CAAC;EACjG,CAAC,CAAC;EACF;EACA;;EAGA,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,IAAIC,yBAAyB;EAE7B,SAASC,SAASA,CAACC,KAAK,EAAE;IACxB,IAAIA,KAAK,CAACC,MAAM,KAAKZ,MAAM,CAACa,aAAa,EAAE;IAE3C,IAAIF,KAAK,CAACG,IAAI,KAAKjB,SAAS,CAACkB,iBAAiB,EAAE;MAC9CV,MAAM,CAACW,mBAAmB,CAAC,SAAS,EAAEN,SAAS,CAAC;MAChDD,yBAAyB,CAAC,CAAC;IAC7B;EACF;EAEA,CAACL,qBAAqB,GAAGJ,MAAM,CAACa,aAAa,MAAM,IAAI,IAAIT,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACa,WAAW,CAACpB,SAAS,CAACkB,iBAAiB,EAAEZ,YAAY,CAAC;EACnL,MAAMe,kBAAkB,GAAG,IAAIC,OAAO,CAACC,OAAO,IAAI;IAChDX,yBAAyB,GAAGW,OAAO;IACnCf,MAAM,CAACgB,gBAAgB,CAAC,SAAS,EAAEX,SAAS,CAAC;EAC/C,CAAC,CAAC;EACF,OAAO;IACL,MAAMO,WAAWA,CAACK,OAAO,EAAEC,QAAQ,EAAE;MACnC,IAAIC,sBAAsB;MAE1B,MAAMN,kBAAkB;MACxB,CAACM,sBAAsB,GAAGxB,MAAM,CAACa,aAAa,MAAM,IAAI,IAAIW,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACP,WAAW,CAACK,OAAO,EAAEnB,YAAY,EAAEoB,QAAQ,CAAC;IAC9K,CAAC;IAEDF,gBAAgBA,CAACV,KAAK,EAAEc,QAAQ,EAAE;MAChC,MAAMC,eAAe,GAAGf,KAAK,IAAI;QAC/B,IAAIA,KAAK,CAACC,MAAM,KAAKZ,MAAM,CAACa,aAAa,EAAE;QAC3CY,QAAQ,CAACd,KAAK,CAAC;MACjB,CAAC;MAEDJ,WAAW,CAACoB,GAAG,CAACF,QAAQ,EAAEC,eAAe,CAAC;MAC1CE,IAAI,CAACP,gBAAgB,CAACV,KAAK,EAAEe,eAAe,CAAC;IAC/C,CAAC;IAEDV,mBAAmBA,CAACL,KAAK,EAAEc,QAAQ,EAAE;MACnC,MAAMC,eAAe,GAAGnB,WAAW,CAACsB,GAAG,CAACJ,QAAQ,CAAC;MACjD,IAAIC,eAAe,IAAI,IAAI,EAAE;MAC7BnB,WAAW,CAACuB,MAAM,CAACL,QAAQ,CAAC;MAC5BG,IAAI,CAACZ,mBAAmB,CAACL,KAAK,EAAEe,eAAe,CAAC;IAClD,CAAC;IAEDzB,SAASA,CAAA,EAAG;MACVI,MAAM,CAACW,mBAAmB,CAAC,SAAS,EAAEN,SAAS,CAAC;MAChD,IAAIR,eAAe,EAAEF,MAAM,CAAC+B,MAAM,CAAC,CAAC;IACtC;EAEF,CAAC;AACH;AAEApC,OAAO,CAACI,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}