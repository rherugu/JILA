{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar types = require('../types.js');\nvar memory = require('../memory.js');\nconst FUNCTION = '_@f';\nfunction createBasicEncoder(api) {\n  const functionsToId = new Map();\n  const idsToFunction = new Map();\n  const idsToProxy = new Map();\n  return {\n    encode,\n    decode,\n    async call(id, args) {\n      const stackFrame = new memory.StackFrame();\n      const func = idsToFunction.get(id);\n      if (func == null) {\n        throw new Error('You attempted to call a function that was already released.');\n      }\n      try {\n        const retainedBy = memory.isMemoryManageable(func) ? [stackFrame, ...func[types.RETAINED_BY]] : [stackFrame];\n        const result = await func(...decode(args, retainedBy));\n        return result;\n      } finally {\n        stackFrame.release();\n      }\n    },\n    release(id) {\n      const func = idsToFunction.get(id);\n      if (func) {\n        idsToFunction.delete(id);\n        functionsToId.delete(func);\n      }\n    },\n    terminate() {\n      functionsToId.clear();\n      idsToFunction.clear();\n      idsToProxy.clear();\n    }\n  };\n  function encode(value, seen = new Map()) {\n    if (value == null) {\n      return [value];\n    }\n    const seenValue = seen.get(value);\n    if (seenValue) {\n      return seenValue;\n    }\n    if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        seen.set(value, [undefined]);\n        const transferables = [];\n        const result = value.map(item => {\n          const [result, nestedTransferables = []] = encode(item, seen);\n          transferables.push(...nestedTransferables);\n          return result;\n        });\n        const fullResult = [result, transferables];\n        seen.set(value, fullResult);\n        return fullResult;\n      }\n      if (memory.isBasicObject(value)) {\n        seen.set(value, [undefined]);\n        const transferables = [];\n        const result = Object.keys(value).reduce((object, key) => {\n          const [result, nestedTransferables = []] = encode(value[key], seen);\n          transferables.push(...nestedTransferables);\n          return {\n            ...object,\n            [key]: result\n          };\n        }, {});\n        const fullResult = [result, transferables];\n        seen.set(value, fullResult);\n        return fullResult;\n      }\n    }\n    if (typeof value === 'function') {\n      if (functionsToId.has(value)) {\n        const id = functionsToId.get(value);\n        const result = [{\n          [FUNCTION]: id\n        }];\n        seen.set(value, result);\n        return result;\n      }\n      const id = api.uuid();\n      functionsToId.set(value, id);\n      idsToFunction.set(id, value);\n      const result = [{\n        [FUNCTION]: id\n      }];\n      seen.set(value, result);\n      return result;\n    }\n    const result = [value];\n    seen.set(value, result);\n    return result;\n  }\n  function decode(value, retainedBy) {\n    if (typeof value === 'object') {\n      if (value == null) {\n        return value;\n      }\n      if (Array.isArray(value)) {\n        return value.map(value => decode(value, retainedBy));\n      }\n      if (FUNCTION in value) {\n        const id = value[FUNCTION];\n        if (idsToProxy.has(id)) {\n          return idsToProxy.get(id);\n        }\n        let retainCount = 0;\n        let released = false;\n        const release = () => {\n          retainCount -= 1;\n          if (retainCount === 0) {\n            released = true;\n            idsToProxy.delete(id);\n            api.release(id);\n          }\n        };\n        const retain = () => {\n          retainCount += 1;\n        };\n        const retainers = new Set(retainedBy);\n        const proxy = (...args) => {\n          if (released) {\n            throw new Error('You attempted to call a function that was already released.');\n          }\n          if (!idsToProxy.has(id)) {\n            throw new Error('You attempted to call a function that was already revoked.');\n          }\n          return api.call(id, args);\n        };\n        Object.defineProperties(proxy, {\n          [types.RELEASE_METHOD]: {\n            value: release,\n            writable: false\n          },\n          [types.RETAIN_METHOD]: {\n            value: retain,\n            writable: false\n          },\n          [types.RETAINED_BY]: {\n            value: retainers,\n            writable: false\n          }\n        });\n        for (const retainer of retainers) {\n          retainer.add(proxy);\n        }\n        idsToProxy.set(id, proxy);\n        return proxy;\n      }\n      if (memory.isBasicObject(value)) {\n        return Object.keys(value).reduce((object, key) => ({\n          ...object,\n          [key]: decode(value[key], retainedBy)\n        }), {});\n      }\n    }\n    return value;\n  }\n}\nexports.createBasicEncoder = createBasicEncoder;","map":{"version":3,"names":["Object","defineProperty","exports","value","types","require","memory","FUNCTION","createBasicEncoder","api","functionsToId","Map","idsToFunction","idsToProxy","encode","decode","call","id","args","stackFrame","StackFrame","func","get","Error","retainedBy","isMemoryManageable","RETAINED_BY","result","release","delete","terminate","clear","seen","seenValue","Array","isArray","set","undefined","transferables","map","item","nestedTransferables","push","fullResult","isBasicObject","keys","reduce","object","key","has","uuid","retainCount","released","retain","retainers","Set","proxy","defineProperties","RELEASE_METHOD","writable","RETAIN_METHOD","retainer","add"],"sources":["/Users/raghavvherugu/Desktop/Projects/name/Jila/node_modules/@remote-ui/rpc/build/cjs/encoding/basic.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar types = require('../types.js');\nvar memory = require('../memory.js');\n\nconst FUNCTION = '_@f';\nfunction createBasicEncoder(api) {\n  const functionsToId = new Map();\n  const idsToFunction = new Map();\n  const idsToProxy = new Map();\n  return {\n    encode,\n    decode,\n\n    async call(id, args) {\n      const stackFrame = new memory.StackFrame();\n      const func = idsToFunction.get(id);\n\n      if (func == null) {\n        throw new Error('You attempted to call a function that was already released.');\n      }\n\n      try {\n        const retainedBy = memory.isMemoryManageable(func) ? [stackFrame, ...func[types.RETAINED_BY]] : [stackFrame];\n        const result = await func(...decode(args, retainedBy));\n        return result;\n      } finally {\n        stackFrame.release();\n      }\n    },\n\n    release(id) {\n      const func = idsToFunction.get(id);\n\n      if (func) {\n        idsToFunction.delete(id);\n        functionsToId.delete(func);\n      }\n    },\n\n    terminate() {\n      functionsToId.clear();\n      idsToFunction.clear();\n      idsToProxy.clear();\n    }\n\n  };\n\n  function encode(value, seen = new Map()) {\n    if (value == null) {\n      return [value];\n    }\n\n    const seenValue = seen.get(value);\n\n    if (seenValue) {\n      return seenValue;\n    }\n\n    if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        seen.set(value, [undefined]);\n        const transferables = [];\n        const result = value.map(item => {\n          const [result, nestedTransferables = []] = encode(item, seen);\n          transferables.push(...nestedTransferables);\n          return result;\n        });\n        const fullResult = [result, transferables];\n        seen.set(value, fullResult);\n        return fullResult;\n      }\n\n      if (memory.isBasicObject(value)) {\n        seen.set(value, [undefined]);\n        const transferables = [];\n        const result = Object.keys(value).reduce((object, key) => {\n          const [result, nestedTransferables = []] = encode(value[key], seen);\n          transferables.push(...nestedTransferables);\n          return { ...object,\n            [key]: result\n          };\n        }, {});\n        const fullResult = [result, transferables];\n        seen.set(value, fullResult);\n        return fullResult;\n      }\n    }\n\n    if (typeof value === 'function') {\n      if (functionsToId.has(value)) {\n        const id = functionsToId.get(value);\n        const result = [{\n          [FUNCTION]: id\n        }];\n        seen.set(value, result);\n        return result;\n      }\n\n      const id = api.uuid();\n      functionsToId.set(value, id);\n      idsToFunction.set(id, value);\n      const result = [{\n        [FUNCTION]: id\n      }];\n      seen.set(value, result);\n      return result;\n    }\n\n    const result = [value];\n    seen.set(value, result);\n    return result;\n  }\n\n  function decode(value, retainedBy) {\n    if (typeof value === 'object') {\n      if (value == null) {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        return value.map(value => decode(value, retainedBy));\n      }\n\n      if (FUNCTION in value) {\n        const id = value[FUNCTION];\n\n        if (idsToProxy.has(id)) {\n          return idsToProxy.get(id);\n        }\n\n        let retainCount = 0;\n        let released = false;\n\n        const release = () => {\n          retainCount -= 1;\n\n          if (retainCount === 0) {\n            released = true;\n            idsToProxy.delete(id);\n            api.release(id);\n          }\n        };\n\n        const retain = () => {\n          retainCount += 1;\n        };\n\n        const retainers = new Set(retainedBy);\n\n        const proxy = (...args) => {\n          if (released) {\n            throw new Error('You attempted to call a function that was already released.');\n          }\n\n          if (!idsToProxy.has(id)) {\n            throw new Error('You attempted to call a function that was already revoked.');\n          }\n\n          return api.call(id, args);\n        };\n\n        Object.defineProperties(proxy, {\n          [types.RELEASE_METHOD]: {\n            value: release,\n            writable: false\n          },\n          [types.RETAIN_METHOD]: {\n            value: retain,\n            writable: false\n          },\n          [types.RETAINED_BY]: {\n            value: retainers,\n            writable: false\n          }\n        });\n\n        for (const retainer of retainers) {\n          retainer.add(proxy);\n        }\n\n        idsToProxy.set(id, proxy);\n        return proxy;\n      }\n\n      if (memory.isBasicObject(value)) {\n        return Object.keys(value).reduce((object, key) => ({ ...object,\n          [key]: decode(value[key], retainedBy)\n        }), {});\n      }\n    }\n\n    return value;\n  }\n}\n\nexports.createBasicEncoder = createBasicEncoder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}