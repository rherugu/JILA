{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar constants = require('./constants.js');\nfunction fromInsideIframe({\n  targetOrigin = '*'\n} = {}) {\n  if (typeof self === 'undefined' || self.parent == null) {\n    throw new Error(`This does not appear to be a child iframe, because there is no parent window.`);\n  } // We wait until the document is ready before advertising to the parent that\n  // communication can commence.\n  // However, it's possible that the parent isn't listening to messages at this time.\n  // Which can lead to communication never starting.\n  // Therefore we also wait for the parent to send a message once it's ready to (re)send the\n  // ready message from within the child iframe.\n\n  const {\n    parent\n  } = self;\n  const ready = () => parent.postMessage(constants.READY_MESSAGE_KEY, targetOrigin);\n  window.addEventListener('message', event => {\n    if (event.source !== parent || document.readyState !== 'complete') {\n      return;\n    }\n    if (event.data === constants.READY_MESSAGE_KEY) {\n      ready();\n    }\n  });\n  if (document.readyState === 'complete') {\n    ready();\n  } else {\n    document.addEventListener('readystatechange', () => {\n      if (document.readyState === 'complete') {\n        ready();\n      }\n    });\n  } // We need to store the listener, because we wrap it to do some origin checking. Ideally,\n  // we’d instead store an `AbortController`, and use its signal to cancel the listeners,\n  // but that isn’t widely supported.\n\n  const listenerMap = new WeakMap();\n  return {\n    postMessage(message, transfer) {\n      parent.postMessage(message, targetOrigin, transfer);\n    },\n    addEventListener(event, listener) {\n      const wrappedListener = event => {\n        if (event.source !== parent) return;\n        listener(event);\n      };\n      listenerMap.set(listener, wrappedListener);\n      self.addEventListener(event, wrappedListener);\n    },\n    removeEventListener(event, listener) {\n      const wrappedListener = listenerMap.get(listener);\n      if (wrappedListener == null) return;\n      listenerMap.delete(listener);\n      self.removeEventListener(event, wrappedListener);\n    }\n  };\n}\nexports.fromInsideIframe = fromInsideIframe;","map":{"version":3,"names":["Object","defineProperty","exports","value","constants","require","fromInsideIframe","targetOrigin","self","parent","Error","ready","postMessage","READY_MESSAGE_KEY","window","addEventListener","event","source","document","readyState","data","listenerMap","WeakMap","message","transfer","listener","wrappedListener","set","removeEventListener","get","delete"],"sources":["/Users/raghavvherugu/Desktop/Projects/name/Jila/node_modules/@remote-ui/rpc/build/cjs/adaptors/iframe-child.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar constants = require('./constants.js');\n\nfunction fromInsideIframe({\n  targetOrigin = '*'\n} = {}) {\n  if (typeof self === 'undefined' || self.parent == null) {\n    throw new Error(`This does not appear to be a child iframe, because there is no parent window.`);\n  } // We wait until the document is ready before advertising to the parent that\n  // communication can commence.\n  // However, it's possible that the parent isn't listening to messages at this time.\n  // Which can lead to communication never starting.\n  // Therefore we also wait for the parent to send a message once it's ready to (re)send the\n  // ready message from within the child iframe.\n\n\n  const {\n    parent\n  } = self;\n\n  const ready = () => parent.postMessage(constants.READY_MESSAGE_KEY, targetOrigin);\n\n  window.addEventListener('message', event => {\n    if (event.source !== parent || document.readyState !== 'complete') {\n      return;\n    }\n\n    if (event.data === constants.READY_MESSAGE_KEY) {\n      ready();\n    }\n  });\n\n  if (document.readyState === 'complete') {\n    ready();\n  } else {\n    document.addEventListener('readystatechange', () => {\n      if (document.readyState === 'complete') {\n        ready();\n      }\n    });\n  } // We need to store the listener, because we wrap it to do some origin checking. Ideally,\n  // we’d instead store an `AbortController`, and use its signal to cancel the listeners,\n  // but that isn’t widely supported.\n\n\n  const listenerMap = new WeakMap();\n  return {\n    postMessage(message, transfer) {\n      parent.postMessage(message, targetOrigin, transfer);\n    },\n\n    addEventListener(event, listener) {\n      const wrappedListener = event => {\n        if (event.source !== parent) return;\n        listener(event);\n      };\n\n      listenerMap.set(listener, wrappedListener);\n      self.addEventListener(event, wrappedListener);\n    },\n\n    removeEventListener(event, listener) {\n      const wrappedListener = listenerMap.get(listener);\n      if (wrappedListener == null) return;\n      listenerMap.delete(listener);\n      self.removeEventListener(event, wrappedListener);\n    }\n\n  };\n}\n\nexports.fromInsideIframe = fromInsideIframe;\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAE7D,IAAIC,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAEzC,SAASC,gBAAgBA,CAAC;EACxBC,YAAY,GAAG;AACjB,CAAC,GAAG,CAAC,CAAC,EAAE;EACN,IAAI,OAAOC,IAAI,KAAK,WAAW,IAAIA,IAAI,CAACC,MAAM,IAAI,IAAI,EAAE;IACtD,MAAM,IAAIC,KAAK,CAAE,+EAA8E,CAAC;EAClG,CAAC,CAAC;EACF;EACA;EACA;EACA;EACA;;EAGA,MAAM;IACJD;EACF,CAAC,GAAGD,IAAI;EAER,MAAMG,KAAK,GAAGA,CAAA,KAAMF,MAAM,CAACG,WAAW,CAACR,SAAS,CAACS,iBAAiB,EAAEN,YAAY,CAAC;EAEjFO,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEC,KAAK,IAAI;IAC1C,IAAIA,KAAK,CAACC,MAAM,KAAKR,MAAM,IAAIS,QAAQ,CAACC,UAAU,KAAK,UAAU,EAAE;MACjE;IACF;IAEA,IAAIH,KAAK,CAACI,IAAI,KAAKhB,SAAS,CAACS,iBAAiB,EAAE;MAC9CF,KAAK,CAAC,CAAC;IACT;EACF,CAAC,CAAC;EAEF,IAAIO,QAAQ,CAACC,UAAU,KAAK,UAAU,EAAE;IACtCR,KAAK,CAAC,CAAC;EACT,CAAC,MAAM;IACLO,QAAQ,CAACH,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;MAClD,IAAIG,QAAQ,CAACC,UAAU,KAAK,UAAU,EAAE;QACtCR,KAAK,CAAC,CAAC;MACT;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF;EACA;;EAGA,MAAMU,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,OAAO;IACLV,WAAWA,CAACW,OAAO,EAAEC,QAAQ,EAAE;MAC7Bf,MAAM,CAACG,WAAW,CAACW,OAAO,EAAEhB,YAAY,EAAEiB,QAAQ,CAAC;IACrD,CAAC;IAEDT,gBAAgBA,CAACC,KAAK,EAAES,QAAQ,EAAE;MAChC,MAAMC,eAAe,GAAGV,KAAK,IAAI;QAC/B,IAAIA,KAAK,CAACC,MAAM,KAAKR,MAAM,EAAE;QAC7BgB,QAAQ,CAACT,KAAK,CAAC;MACjB,CAAC;MAEDK,WAAW,CAACM,GAAG,CAACF,QAAQ,EAAEC,eAAe,CAAC;MAC1ClB,IAAI,CAACO,gBAAgB,CAACC,KAAK,EAAEU,eAAe,CAAC;IAC/C,CAAC;IAEDE,mBAAmBA,CAACZ,KAAK,EAAES,QAAQ,EAAE;MACnC,MAAMC,eAAe,GAAGL,WAAW,CAACQ,GAAG,CAACJ,QAAQ,CAAC;MACjD,IAAIC,eAAe,IAAI,IAAI,EAAE;MAC7BL,WAAW,CAACS,MAAM,CAACL,QAAQ,CAAC;MAC5BjB,IAAI,CAACoB,mBAAmB,CAACZ,KAAK,EAAEU,eAAe,CAAC;IAClD;EAEF,CAAC;AACH;AAEAxB,OAAO,CAACI,gBAAgB,GAAGA,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}